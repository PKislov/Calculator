#ifndef STRINGTONUMBER
#define STRINGTONUMBER


/////////////////////////////////////////////////////////////////////////////////////////////////////////
///		stringtonumber.h - описание класса StringToNumber вычисления арифметического выражения,
///						   записанного в символьном массиве.
///
///						АРИФМЕТИЧЕСКИЙ КАЛЬКУЛЯТОР 1.0
///
///
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "definitions.h"
#include "complex.h"

extern struct complex answer, // предыдущее вычисленное значение, определяет метку ans в строке-формуле, изначально равно 0
                               temp_complex_number,
                               null;

extern bool error, // равно true если в ходе вычисления строки обнаружена ошибка;

Write,  // определяет необходимость вывода результата выражения на экран (например,
               // если все выражение состоит из одного объявления новой переменной, то на экран
               // не выводится никакой результат);

ThisComment,	// определяет, состоит ли всё выражение из одного комментария;

ThisBoolValue;

//===============================================================================================================
// ГЛАВНЫЙ КЛАСС вычисления арифметического выражения:

class StringToNumber
{
//=================== ЗАКРЫТЫЕ МЕТОДЫ И СВОЙСТВА ================================================================
//===============================================================================================================
// СВОЙСТВА:

    // Структура двусвязанного списка лексем, который создается при синтаксическом анализе выражения.
    // В каждом элементе списка хранится (число, оператор, функция.и т.д.).
    // Что именно хранится (тип данных, название функции и т.д.), определяет параметр ThisIs.
    struct token
    {
        double number,		 // хранит реальную часть числа
               Im_number;	 // хранит мнимую часть числа

        THIS_IS ThisIs;		 // этот параметр определяет тип данных (число, оператор, функция и т.д.)
                             // элемента списка, равно одному из макроопределений, перечисленных в файле Definitions.h.
                             // В ходе вычисления выражения может переопределяться по мере необходимости.

        int IndexVar,		 // если лексема является переменной, этот индекс указывает на элемент списка пользовательских
                             // переменных (массив структур с членами имя переменной и её значение).

            IndexString;	 // если лексема является строкой, этот индекс указывает на массив строк strings

        struct token *next,  // указатель на следующий элемент списка
                     *prior; // указатель на предыдущий элемент

    }	*start, // указатель на начало списка;
        *end,   // указатель на конец списка;
        *temp,  // указатель для навигации по списку;
        *Next;  // для отладочных утверждений (при навигации по списку).

    int countString,	 // счетчик строк в массиве strings

        countToken,		 // определяет количество элементов в списке, если равно 1,
                         // вычисления заканчиваются и главный метод StrToNum возвращает результат выражения.

        iteration;		 // вспомогательный счетчик итераций циклов разбиения строки на лексемы и вычисления выражения.
                         // если счетчик "зашкаливает", это свидетельствует о неправильном построении выражения. Практически, это
                         // единственный безотказный контроль наличия синтаксических ошибок в выражении.

    char strings [QUANTITY_STRINGS][MAX_STRING]; // массив строк для хранения строковых аргументов функции Integral


//===============================================================================================================
// МЕТОДЫ РАБОТЫ СО СПИСКОМ:

// добавляет в конец двусвязного списка новый элемент, если список пустой, то вставляется первый элемент.
    void AddInEndVersionShildt (token *, token **),

// удаляет элемент из двусвязного списка, по необходимости переопределяя указатели на начало и конец списка
// (если удаляется первый или последний элемент). Две функции AddInEndVersionShildt и DelElementMyVersion -
// единственные "импортные функции" программы, взятые из книги "Полный справочник по С" Г.Шилдта.
         DelElementMyVersion   (token *,
                                token **,
                                token **),

// Функция освобождает память от списка, вызывается после завершения вычислений, но диспетчер задач Windows не
// отражает уменьшения объема памяти, занимаемого программой, но сбоев приложения не происходит.
         DeleteAll (token **),

//===============================================================================================================
// МЕТОДЫ ВЫЧИСЛЕНИЯ ОПЕРАТОРОВ:

         UnMinus   (), // вычисляет минус числа
         UnPlus    (), // вычисляет плюс числа
         Not	   (), // логичекий оператор отрицания
         Factorial (), // вычисляет факториал числа

         DelBreckets						     (token *), // удаление скобок, вызывается функциями DelBrecketsAroundNumber и DelBrecketsAroundArgumentsOfFunction1Argument
         DelBrecketsAroundNumber						(), // удаление скобок вокруг числа
         DelModulsAroundNumber							(), // нахождение модуля вещ. или комплексного числа
         Del_2_Elements									(); // удаление двух элементов справа от текущей лексемы (используется повсеместно)

//===============================================================================================================
// МЕТОДЫ-ПРЕДИКАТЫ ОПРЕДЕЛЕНИЯ ПРИОРИТЕТОВ ЛЕКСЕМ:
// возвращают результат относительно текущей позиции указателя temp-навигатора по списку.

    bool IsFunction						 (token *); // Лексема является функцией или оператором-функцией ?

    // Функции вычисления приоритетов соседних лексем, возвращают истину, если утвердительно отвечают на вопрос:
    bool OperatorSupremePrioritet		 (token *); // Лексема является оператором высшего приоритета или функцией ? (вызывает IsSupremOperator и IsFunction)
    bool IsSupremOperator				 (token *); // Лексема является оператором высшего приоритета ?
    bool IsMiddleOperator				 (token *); // Лексема является оператором среднего приоритета ?
    bool IsUnOperator					 (token *); // Лексема является унарным оператором (+, -, not) ?
    bool LeftOperatorSupremePrioritet			(); // Приоритет левой лексемы выше ?
    bool RightThirdOperatorSupremePrioritet		(); // Приоритет третьей справа лексемы выше ?
    bool LeftOperatorSupremePrioritet_2			(); // Приоритет левой лексемы выше ?
    bool RightThirdOperatorSupremePrioritet_2	(); // Приоритет третьей справа лексемы выше ?
    bool RightSecondOperatorSupremePrioritet	(); // Приоритет второй справа лексемы выше ?
    bool RightFifthOperatorSupremePrioritet		(); // Приоритет пятой справа лексемы выше ? (используется для дробей из трех чисел)
    bool IsRealNumberOrVar				 (token *);	// Является ли лексема вещественным число ?
    bool IsImNumberOrVar				 (token *); // Является ли лексема комплексным число ?
    bool IsFunction1Arg					 (token *); // Является ли лексема функцией от одного аргумента ?
    bool IsFunction2Arg					 (token *); // Является ли лексема функцией от двух аргументов ?
    bool IsFunction3Arg					 (token *); // Является ли лексема функцией от двух аргументов ?

    bool IsNumberOrVariable				 (token *ptr) // возвращает истину если лексема является числом или переменной или булевым значением
    {
        return ptr->ThisIs == NUMBER || ptr->ThisIs == VARIABLE || ptr->ThisIs == BOOL;
    }

    bool IsMemberStruct (token *ptr) // возвращает истину, если лексема является идентификатором комплексной или действительной части значения переменной
    {
        return ptr->ThisIs == MEMBER_STRUCT_RE || ptr->ThisIs == MEMBER_STRUCT_IM;
    }

//===============================================================================================================
// МЕТОДЫ ВЫЧИСЛЕНИЯ ФУНКЦИЙ ОТ ОДНОГО АРГУМЕНТА:

    //  удаление лишних скобок вокруг параметра функции от одного аргумента, например ехр[(3)] -> exp(3)
    void DelBrecketsAroundArgumentsOfFunction1Argument ();

    // вызывает целый ряд методов для определения и вычисления конкретной функции
    void Functions_Of1Arguments ();


    // выполняет функцию или функцию-оператор. Параметр ptr_arg указывает на аргумент функции,
    // n равно 1 при выполнении функции-оператора или 3 в случае функции.
    void RunFunction1Arg (token *ptr_arg, int n);
    // Пример для функций-операторов: ДО ВЫЗОВА ФУНКЦИИ
    //		лексема а:		лексема b:		лексема с:
    //
    //		ЕХР				NUMBER			...
    //		<нет записи>	1				...
    //		next -> b		next -> с		next -> ...
    //		... <- prior	a <- prior		b <- prior
    //
    //		 ПОСЛЕ ВЫЗОВА ФУНКЦИИ
    //		лексема а:		лексема c:	(лексема b удалена)
    //
    //		NUMBER			...
    //		2.712
    //		next -> c		next -> ...
    //		... <- prior	a <- prior}
    // Для всех функций единый алгоритм.

    void Function_Of1Argument ();



    // МЕТОДЫ ВЫЧИСЛЕНИЯ ФУНКЦИЙ-ОПЕРАТОРОВ:
    // Функции-операторы подобны обычным функциям с одним аргументом и отличаются тем, что являются агрегатными операторами и для них
    // есть место в таблице приоритетов операторов, а значит вычисляются по строгим правилам. Например, sin 30 + 1 = sin(30) + 1 = 1.5 -
    // в первом случае используется оператор синус числа, а во втором - функция, результат тот же так как приоритет оператора плюс меньше
    // оператора синуса. С другой строны, sin 30 ^ 2 + 1 = 1, sin(30) ^ 2 + 1 = 1.25. В принципе функции-операторы являются излишними в данной
    // программе, но я их оставил с целью уменьшения количества скобок в выражениях и лучшей наглядности.

    void Functions_Operators_Of1Arguments (); // вызывает целый ряд методов для определения и вычисления конкретной функции-оператора


     // вызывает, в зависимости от типа лексемы, одну из функций от одного аргумента
    void Function_OperatorOf1Argument ();

    //===============================================================================================================
// МЕТОДЫ ВЫЧИСЛЕНИЯ ФУНКЦИЙ ОТ ДВУХ АРГУМЕНТОВ:

// Принцип написания: <имя_функции> (<аргумент_1>, <аргумент_2>);

    bool IsFunctionOf2Arguments (); // Лексема является функцией от двух аргументов?
    void Functions_Of2Arguments (); // вызывает целый ряд методов для определения и вычисления конкретной функции.
    void hypot ();
    void log_ ();
    void rand_ ();
    void middle ();
    void max_ ();
    void min_ ();
    void nod ();
    void pow_ ();


//===============================================================================================================
// МЕТОДЫ ВЫЧИСЛЕНИЯ ФУНКЦИЙ ОТ ТРЕХ АРГУМЕНТОВ:


    bool IsFunctionOf3Arguments (); // Лексема является функцией вычисления интеграла?
    void Functions_Of3Arguments (); // вызывает целый ряд методов для определения и вычисления конкретной функции.
    void integral (); // Вычисление определенного интеграла методом Симпсона.


//===============================================================================================================
// МЕТОДЫ РАБОТЫ С ПОЛЬЗОВАТЕЛЬСКИМИ ПЕРЕМЕННЫМИ:

// Массив пользовательских переменных ListVar:
public: struct
    {
        double ValueVar,    // вещественное значение переменной
        Im_ValueVar; // мнимое значение переменной

        char   NameVar [SIZE_UNIQUE_WORD_AND_VARIABLES]; // имя переменной, регистр учитывается, имена в списке переменных не повторяются

    } ListVar [QUANTITY_VARIABLES],
    OLDListVar [QUANTITY_VARIABLES];	// массив пользовательских переменных до вычисления выражения. Если в ходе
                                    // вычисления выражения нашлись ошибки, то массив переменных возвращается
                                    // в исходное состояние, что делается с целью отката нежелательных изменений
                                    // значений переменных, таким образом ошибка не повлияет на целостность данных.

    void AddVariableInList		(char *add), // записывает пользовательскую переменную с именем add в список
         ChangeValueVariable	(char *add, double Re_value, double Im_value), // меняет значения переменной add на указаные в параметрах
         CreateVariable			(char *add), // создает и записывает в массив пользовательских переменных переменную add, инициализирует нулями
         CopyVariables			(StringToNumber &t); // копирует массив пользовательских переменных в массив объекта t

    int countVariables,		// счетчик пользовательских переменных - общее их число в массиве.
        OLDcountVariables;	// значение countVariables до вычисления выражения. Если в ходе
                            // вычисления выражения нашлись ошибки, то только что созданные
                            // переменные должны быть удалены с помощью утверждения
                            // countVariables = OLDcountVariables, после чего новые переменные
                            // будут недоступными

    private:

    bool EqualNamesUnique  (char *str); // возвращает истину если строка str не совпадает ни с одним названием функции или оператора
    void SaveValue		   (double Re_value, double Im_value); // метод применяется в случае присваивании переменной значения. Новое значение копируется в
                                           // список пользовательских переменных и записывается члену number структуры лексемы значение value

    //===============================================================================================================
// методы поиска синтаксических ошибок в арифметическом выражении

    // Функция выводит сообщение об ошибке и устанавливает флаг error в истину, если в выражении
    // не сбалансированы скобки.
    void SearchBreckets ();


    // функция поиска некоторых синтаксических ошибок в выражении
    void SearchErrors ();

//=================== ОТКРЫТЫЕ МЕТОДЫ И СВОЙСТВА ================================================================

    public:

        StringToNumber  (); // конструктор класса

        complex StrToNum (char *); // главный метод вычисления выражения. Входной параметр: строка с арифметическим
        // выражением. Возвращаемое значение: указатель на структуру, содержащую результат вычисления выражения.

private: void FillingListLexeme (char *); // метод создания двусвязного списка лексем, вызывается
         // методом StrToNum, принимая его параметр.

         void Undo ();	// функция отката, вызывается в случае обнаружения ошибки в выражении,
                        // в результате чего новые переменные удаляются, а массив переменных
                        // вовзвращается в исходное состояние, список лексем удаляется из памяти.
                        // Откат производится с целью сохранения целостности данных (пользовательских
                        // переменных) от ошибочных действий (инициализации, ...).


}; // class StringToNumber

//===============================================================================================================

#endif // STRINGTONUMBER

